<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moonstone List Generator</title>

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- PapaParse for robust CSV parsing (handles quotes/commas) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-BYBM86ZXL3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);} 
    gtag('js', new Date());
    gtag('config', 'G-BYBM86ZXL3');
  </script>

  <style>
    .card { @apply bg-white/80 backdrop-blur rounded-2xl shadow p-5; }
    .pill { @apply inline-block px-3 py-1 rounded-full text-xs font-medium bg-gray-100; }
    .mono { font-variant-numeric: tabular-nums; }
    details > summary { cursor: pointer; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-50 to-slate-200 text-slate-800">
  <div class="max-w-3xl mx-auto px-4 py-8 space-y-6">
    <header class="space-y-2">
      <h1 class="text-3xl font-bold">Moonstone List Generator</h1>
      <p class="text-slate-600">Pick a faction (or Random), generate three sets, and list only characters valid for that faction. If needed, we add extra sets until you reach at least 8 characters. Special rules applied for Murder Bunnies, Psychopomps, and Anya/Striga Anya.</p>
    </header>

    <section class="card space-y-4">
      <div class="flex flex-col md:flex-row gap-3 items-start md:items-end">
        <div class="grow">
          <label class="block text-sm font-semibold mb-1" for="factionSelect">Faction</label>
          <select id="factionSelect" class="w-full rounded-lg border px-3 py-2">
            <option disabled selected>Loading factions…</option>
          </select>
        </div>
        <div class="shrink-0 flex gap-2">
          <button id="generateBtn" class="rounded-xl bg-blue-600 hover:bg-blue-700 text-white font-semibold px-5 py-2.5 disabled:opacity-50">Generate</button>
          <button id="rerollBtn" class="rounded-xl bg-slate-200 hover:bg-slate-300 text-slate-800 font-semibold px-5 py-2.5 disabled:opacity-50">Re‑roll</button>
        </div>
      </div>
      <p class="text-xs text-slate-500">Data source: <code class="mono">models.csv</code> in this folder (headers: Set, Character, Faction, Faction 2).</p>
    </section>

    <section id="results" class="space-y-6 hidden">
      <div id="note" class="hidden p-3 rounded-lg bg-amber-100 text-amber-900 text-sm"></div>

      <div class="card space-y-2">
        <h2 class="text-xl font-semibold">Chosen Sets</h2>
        <div id="chosenSets" class="flex flex-wrap gap-2"></div>
      </div>

      <div class="card space-y-2">
        <div class="flex items-center justify-between">
          <h2 class="text-xl font-semibold">Characters (<span id="charCount">0</span>)</h2>
          <button id="copyBtn" class="text-sm px-3 py-1 rounded-lg border hover:bg-slate-50">Copy list</button>
        </div>
        <ul id="characterList" class="list-disc pl-6 space-y-1"></ul>
      </div>

      <details class="card">
        <summary class="text-sm font-semibold">Debug info</summary>
        <div id="debug" class="mt-3 text-xs whitespace-pre-wrap font-mono"></div>
      </details>
    </section>

    <footer class="text-xs text-slate-500 pt-8">
      © Moonstone tools — List Generator.
    </footer>
  </div>

  <script>
    /**********************
     * Constants & State
     **********************/
    const CSV_URL = 'models.csv';

    // Only allow these 4 factions in the dropdown (plus Random), to avoid junk tokens in your CSV.
    // Edit this list if you ever add more top-level factions.
    const FACTION_WHITELIST = ['Commonwealth','Leshavult','Dominion','Shades'];

    // Exclusion rules for characters that should never count
    const EXCLUDED_KEYWORDS = ['murder bunn', 'psychopomp']; // case-insensitive substrings

    // Anya/Striga merge rule (counts as a single choice overall)
    const ANYA_ALIASES = ['anya', 'striga anya', 'anya / striga anya'];

    const RANDOM_LABEL = 'Random';

    const state = {
      rows: [],          // normalized rows
      bySet: new Map(),  // setName -> rows[]
      discoveredFactions: new Set(), // from data
      lastResult: null
    };

    const $ = (id) => document.getElementById(id);
    const factionSelect = $('factionSelect');
    const generateBtn = $('generateBtn');
    const rerollBtn = $('rerollBtn');
    const results = $('results');
    const chosenSetsEl = $('chosenSets');
    const characterListEl = $('characterList');
    const charCountEl = $('charCount');
    const noteEl = $('note');
    const debugEl = $('debug');
    const copyBtn = $('copyBtn');

    /**********************
     * Helpers
     **********************/
    const toTitle = (s) => s.replace(/\s+/g, ' ').trim().toLowerCase().replace(/(^|\s)\S/g, c => c.toUpperCase());
    const norm = (s) => (s||'').trim().toLowerCase();

    function splitFactionTokens(val) {
      if (!val) return [];
      // split by common delimiters: / , ; & |
      return val
        .split(/[\/,;&|]/)
        .map(v => toTitle(v))
        .filter(v => v.length > 0);
    }

    function isExcludedCharacter(name) {
      const n = norm(name);
      return EXCLUDED_KEYWORDS.some(k => n.includes(k));
    }

    function mergeAnyaGlobally(charList) {
      let hasAnyAnya = charList.some(c => ANYA_ALIASES.includes(norm(c)));
      if (!hasAnyAnya) return charList;
      // remove all anya-related entries
      const filtered = charList.filter(c => !ANYA_ALIASES.includes(norm(c)));
      // add the merged label once
      filtered.push('Anya / Striga Anya');
      return filtered;
    }

    function uniquePreserveOrder(arr) {
      const seen = new Set();
      const out = [];
      for (const x of arr) {
        const key = norm(x);
        if (!seen.has(key)) { seen.add(key); out.push(x); }
      }
      return out;
    }

    function pickRandom(arr, n, rng = Math.random) {
      const copy = arr.slice();
      for (let i = copy.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy.slice(0, n);
    }

    function chooseFaction(requested) {
      if (requested === RANDOM_LABEL) {
        const list = Array.from(state.discoveredFactions).filter(f => FACTION_WHITELIST.includes(f));
        const pool = list.length ? list : FACTION_WHITELIST; // fallback to whitelist if none discovered
        const i = Math.floor(Math.random() * pool.length);
        return pool[i];
      }
      return requested;
    }

    /**********************
     * Load & Normalize CSV
     **********************/
    async function loadCSV() {
      const res = await fetch(CSV_URL, { cache: 'no-store' });
      if (!res.ok) throw new Error('Could not load models.csv');
      const text = await res.text();
      const parsed = Papa.parse(text, {
        header: true,
        skipEmptyLines: 'greedy',
        transformHeader: h => h.trim(),
      });
      if (parsed.errors && parsed.errors.length) {
        console.warn('CSV parse errors:', parsed.errors);
      }
      const rowsRaw = parsed.data || [];

      // Normalize rows
      const rows = [];
      const bySet = new Map();
      const discovered = new Set();

      for (const r of rowsRaw) {
        const SetName = (r['Set'] ?? '').toString().trim();
        const Character = (r['Character'] ?? '').toString().trim();
        const f1 = splitFactionTokens((r['Faction'] ?? '').toString());
        const f2 = splitFactionTokens((r['Faction 2'] ?? r['Faction2'] ?? '').toString());
        if (!SetName || !Character) continue;

        const factions = uniquePreserveOrder([...f1, ...f2]);
        factions.forEach(f => discovered.add(f));

        const row = { Set: SetName, Character, factions };
        rows.push(row);
        if (!bySet.has(SetName)) bySet.set(SetName, []);
        bySet.get(SetName).push(row);
      }

      state.rows = rows;
      state.bySet = bySet;
      state.discoveredFactions = discovered;
    }

    function populateFactionDropdown() {
      factionSelect.innerHTML = '';
      const optR = document.createElement('option');
      optR.value = RANDOM_LABEL; optR.textContent = RANDOM_LABEL; factionSelect.appendChild(optR);

      // Only show factions that are in the whitelist and present in the data.
      const list = FACTION_WHITELIST.filter(f => state.discoveredFactions.has(f));
      // If the CSV didn’t use the expected naming, fall back to whatever was discovered (sorted), but this is noisy.
      const finalList = list.length ? list : Array.from(state.discoveredFactions).sort((a,b)=>a.localeCompare(b));

      for (const f of finalList) {
        const opt = document.createElement('option');
        opt.value = f; opt.textContent = f; factionSelect.appendChild(opt);
      }
    }

    /**********************
     * Core logic
     **********************/
    function charactersForSetAndFaction(setName, chosenFaction) {
      const rows = state.bySet.get(setName) || [];
      // Filter to rows whose factions contain the chosen faction (case-insensitive)
      let chars = rows
        .filter(r => r.factions.map(norm).includes(norm(chosenFaction)))
        .map(r => r.Character)
        .filter(Boolean)
        .filter(c => !isExcludedCharacter(c));
      return chars;
    }

    function eligibleSetsForFaction(chosenFaction) {
      const eligible = [];
      for (const [setName] of state.bySet.entries()) {
        const chars = charactersForSetAndFaction(setName, chosenFaction);
        if (chars.length > 0) eligible.push(setName);
      }
      return eligible;
    }

    function generateListForFaction(requestedFaction) {
      const chosenFaction = chooseFaction(requestedFaction);
      const eligibleSets = eligibleSetsForFaction(chosenFaction);

      if (eligibleSets.length === 0) {
        return { faction: chosenFaction, sets: [], characters: [], addedExtra: false, message: 'No eligible sets for this faction in the data.' };
      }

      const chosen = pickRandom(eligibleSets, Math.min(3, eligibleSets.length));
      let allChars = [];
      for (const s of chosen) {
        allChars.push(...charactersForSetAndFaction(s, chosenFaction));
      }

      let addedExtra = false;
      const remaining = eligibleSets.filter(s => !chosen.includes(s));

      while (allChars.length < 8 && remaining.length > 0) {
        addedExtra = true;
        const next = pickRandom(remaining, 1)[0];
        chosen.push(next);
        const ix = remaining.indexOf(next);
        if (ix >= 0) remaining.splice(ix, 1);
        allChars.push(...charactersForSetAndFaction(next, chosenFaction));
      }

      // Global merge for Anya/Striga and de-duplication
      allChars = mergeAnyaGlobally(allChars);
      const uniqueChars = uniquePreserveOrder(allChars);

      return {
        faction: chosenFaction,
        sets: chosen,
        characters: uniqueChars,
        addedExtra,
        message: uniqueChars.length < 8 ? 'Could not reach 8 characters with available sets (after exclusions). Consider widening the faction or adding more sets.' : ''
      };
    }

    /**********************
     * Render
     **********************/
    function renderResult(result, requestedFaction) {
      results.classList.remove('hidden');

      if (result.addedExtra) {
        noteEl.textContent = 'Fewer than 8 characters were found from the first three sets, so I added an extra set.';
        noteEl.classList.remove('hidden');
      } else if (result.message) {
        noteEl.textContent = result.message;
        noteEl.classList.remove('hidden');
      } else {
        noteEl.classList.add('hidden');
      }

      chosenSetsEl.innerHTML = '';
      result.sets.forEach(s => {
        const span = document.createElement('span');
        span.className = 'pill';
        span.textContent = s;
        chosenSetsEl.appendChild(span);
      });

      characterListEl.innerHTML = '';
      result.characters.forEach(c => {
        const li = document.createElement('li');
        li.textContent = c;
        characterListEl.appendChild(li);
      });
      charCountEl.textContent = result.characters.length;

      // Debug info
      const eligCount = eligibleSetsForFaction(result.faction).length;
      debugEl.textContent = [
        `Requested: ${requestedFaction}`,
        `Chosen faction: ${result.faction}`,
        `Eligible sets for faction: ${eligCount}`,
        `Sets chosen: ${result.sets.length}`,
        `Characters listed: ${result.characters.length}`
      ].join('\n');

      try { gtag('event', 'generate', { event_category: 'list_generator', event_label: `Req:${requestedFaction} -> Chosen:${result.faction}`, value: result.characters.length }); } catch {}
    }

    function copyCharactersToClipboard() {
      const items = Array.from(characterListEl.querySelectorAll('li')).map(li => '• ' + li.textContent);
      const sets = Array.from(chosenSetsEl.querySelectorAll('span')).map(s => s.textContent);
      const txt = [
        'Moonstone List Generator',
        '',
        'Sets:',
        ...sets.map(s => '- ' + s),
        '',
        `Characters (${items.length}):`,
        ...items
      ].join('\n');
      navigator.clipboard.writeText(txt).then(() => {
        copyBtn.textContent = 'Copied!';
        setTimeout(() => copyBtn.textContent = 'Copy list', 1200);
      });
    }

    /**********************
     * Wire-up & Init
     **********************/
    copyBtn.addEventListener('click', copyCharactersToClipboard);

    function runGenerate() {
      const requested = factionSelect.value;
      const result = generateListForFaction(requested);
      state.lastResult = result;
      renderResult(result, requested);
    }

    generateBtn.addEventListener('click', runGenerate);
    rerollBtn.addEventListener('click', runGenerate);

    (async function init() {
      try {
        await loadCSV();
        populateFactionDropdown();
        generateBtn.disabled = false; rerollBtn.disabled = false;
      } catch (err) {
        factionSelect.innerHTML = '<option>Error loading models.csv</option>';
        generateBtn.disabled = true; rerollBtn.disabled = true;
        console.error(err);
        alert(err.message);
      }
    })();
  </script>
</body>
</html>

